## 外部模板

- 主要目的是为避免编译器和链接器的大量“去除冗余的实例化”工作。
- 对于源代码中出现的每一处模板实例化，编译器都需要去做实例化的工作；而在链接时，链接器还需要移除重复的实例化代码。
- 很明显，这样的工作太过冗余，而在广泛使用模板的项目中，由于编译器会产生大量冗余代码，会极大地增加编译器的编译时间和链接时间
- C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化


###　extern关键字

- “外部”（extern）这个概念早在C的时候已经就有了。
- 通常情况下，我们在一个文件中a.c中定义了一个变量int i，而在另外一个文件b.c中想使用它，这个时候我们就会在没有定义变量i的b.c文件中做一个外部变量的声明。

```
extern int i;
```

### 外部模版用法

- 强制编译器在特定位置开始实例化的语法：

```
extern template class std::vector<MyClass>;  
```

- 这样就告诉编译器不要在该编译单元内将该模板实例化。

```cpp

//fun.h  
template <typename T>  
void fun(T t){  
}  
  
//use1.cpp  
void test1(){  
    fun<int>(1);  
}  
  
//use2.cpp  
  
extern template void fun<int>(int);  
void test2(){  
    fun<int>(1);  
} 
```